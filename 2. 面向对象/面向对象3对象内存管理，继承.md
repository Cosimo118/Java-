**对象内存管理**

* 编译好的Java程序需要运行在JVM种
* 程序，无论代码还是数据，都需要存储在内存中，JVM为Java程序提供并管理所需要的内存空间
* JVM内存分为堆，栈，方法区三个区域，分别用于存储不同的数据

**对象存储在堆中**

* JVM在其内存空间开辟一个称为堆的存储空间
* 这部分空间用于存储使用new关键字所创建的对象

**成员变量的生命周期**

* 访问对象需要依靠引用变量
* 当一个对象没有任何引用时，被视为废弃的对象，属于被回收的范围，该对象中的所有成员变量也随之被回收
* 成员变量的生命周期为：从对象在堆中创建开始到对象从堆中被回收结束![1568610083821](C:\Users\cxt66\AppData\Roaming\Typora\typora-user-images\1568610083821.png)

**垃圾回收机制**

* 垃圾回收器(Garbage Collection, GC)是JVM自带的一个线程（自动运行着的程序），用于回收没有任何引用指向的对象。
* Java程序员不用担心内存管理，因为垃圾收集器会自动进行回收管理。

**Java程序的内存泄漏问题**

* 内存泄漏是指，不再使用的内存没有被及时的回收，严重的内存泄漏会因过多的内存占用而导致程序的崩溃
* GC线程判断对象是否可以回收的依据是该对象是否有引用指向，因此，当确定该对象不再使用时，应该及时将其引用设置为null

**System.gc方法**

* GC的回收对程序员来说是透明的，并不一定以发现有无引用的对象就立刻回收
* 当我们需要GC线程即刻回收无用对象时，可以调用System.gc()方法
* System.gc()用于建议虚拟机马上调度GC线程回收资源，具体的实现策略取决于不同的JVM系统

**1.3.非堆——栈**

**栈用于存放方法中的局部变量**

* 栈空间用于存储程序运行时在方法中声明的所有局部变量

```java
Cell c = new Cell();
int num = 5;
```

![1568611335522](C:\Users\cxt66\AppData\Roaming\Typora\typora-user-images\1568611335522.png)

**局部变量的生命周期**

* 一个运行的java程序从开始到结束会有多次方法的调用。JVM会为每一个方法的调用在栈中分配一个对应的空间，这个空间称为该方法的栈帧
* 一个栈帧对应一个调用中的方法，栈帧中存储了该方法的参数，局部变量等数据。当某一个方法调用完成后，其对应的栈帧将被清除，局部变量失效

**成员变量和局部变量**

* 成员变量和局部变量差别如下
* 局部变量

—定义在方法中

—没有默认值，必须自行设定初始值

—方法被调用时，存在栈中，方法调用结束，从栈中清除

* 成员变量

—定义在类中，方法外

—有默认初始值，可以不显式初始化

—所在类被实例化后，存在堆中，对象被回收时，成员变量失效

**方法区用于存放类的信息**

* 方法区用于存放类的信息，Java程序运行时，首先会通过类装载器载入类文件的字节码信息，经过解析后将其装入方法区，类的各种信息（包括方法）否在方法去存储

![1568620412320](C:\Users\cxt66\AppData\Roaming\Typora\typora-user-images\1568620412320.png)

**方法只有一份**

* 当类的信息被加载到方法区时，除了类的类型信息以外，同时类内的方法定义也被加载到方法区

* 类在实例化对象时，多个对象会拥有各自在堆中的空间，但所有实例对象是公用在方法区中的一份方法定义的

**2. 继承**

![1568620755807](C:\Users\cxt66\AppData\Roaming\Typora\typora-user-images\1568620755807.png)

**extends关键字**

* 通过extends关键字可以实现类的继承
* 子类（Sub class）可以继承父类（Super class)的成员变量及成员方法，同时也可以定义自己的成员变量和成员方法；
* Java语言不支持多重继承，一个类只能继承一个父类，但一个父类可以有多个子类

**继承中构造方法**

* 子类的构造方法中必须通过super关键字调用父类的构造方法，这样可以妥善的初始化继承自父类的成员变量
* 如果子类的构造方法中没有调用父类的构造方法，Java编译器会自动的加入对父类无参构造方法的调用（如果父类没有无参的构造方法，会有编译错误）

![1568621233165](C:\Users\cxt66\AppData\Roaming\Typora\typora-user-images\1568621233165.png)

![1568621249054](C:\Users\cxt66\AppData\Roaming\Typora\typora-user-images\1568621249054.png)

**父类的引用指向子类的对象**

* 一个子类的对象可以向上造型为父类的类型，即，定义夫类型的引用可以指向子类的对象

![1568621453941](C:\Users\cxt66\AppData\Roaming\Typora\typora-user-images\1568621453941.png)

* 父类的引用可以指向子类的对象，但通过父类的引用只能访问父类所定义的成员，不能访问子类扩展的部分

![1568621734010](C:\Users\cxt66\AppData\Roaming\Typora\typora-user-images\1568621734010.png)